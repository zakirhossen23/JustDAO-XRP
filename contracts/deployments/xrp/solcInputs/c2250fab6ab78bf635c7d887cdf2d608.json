{
  "language": "Solidity",
  "sources": {
    "contracts/JustDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport './utils/Strings.sol';\r\ncontract JustDAO {\r\n    struct dao_uri_struct {\r\n        string dao_wallet;\r\n        string dao_uri;\r\n        string finished;\r\n    }\r\n    struct goal_uri_struct {\r\n        uint256 dao_id;\r\n        string goal_uri;\r\n    }\r\n\r\n    struct ideas_uri_struct {\r\n        uint256 goal_id;\r\n        string ideas_uri;\r\n        uint256 donation;\r\n    }\r\n\r\n    struct donation_struct {\r\n        uint256 ideas_id;\r\n        string wallet;\r\n        uint256 donation;\r\n    }\r\n\r\n    struct smart_contract_uri_struct {\r\n        uint256 smart_contract_id;\r\n        uint256 ideas_id;\r\n        string smart_contract_uri;\r\n    }\r\n    struct goal_ideas_votes_struct {\r\n        uint256 goal_id;\r\n        uint256 ideas_id;\r\n        string wallet;\r\n    }\r\n    struct message_struct {\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string message;\r\n        string sender;\r\n    }\r\n    struct message_read_struct {\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string wallet;\r\n        string msg_type;\r\n    }\r\n    struct reply_struct {\r\n        uint256 reply_id;\r\n        uint256 message_id;\r\n        uint256 ideas_id;\r\n        string message;\r\n    }\r\n\r\n    struct UnbondingRequest {\r\n        int64 completionTime;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct join_struct {\r\n        uint256 daoid;\r\n        string wallet;\r\n    }\r\n\r\n    struct user_badge_struct {\r\n        string wallet;\r\n        bool dao;\r\n        bool joined;\r\n        bool goal;\r\n        bool ideas;\r\n        bool vote;\r\n        bool donation;\r\n        bool comment;\r\n        bool reply;\r\n    }\r\n    uint256 public _dao_ids;\r\n    uint256 public _donations_ids;\r\n    uint256 public _goal_ids;\r\n    uint256 public _ideas_ids;\r\n    uint256 public _join_ids;\r\n    uint256 public _smart_contract_ids;\r\n    uint256 public _ideas_vote_ids;\r\n    uint256 public _message_ids;\r\n    uint256 public _message_read_ids;\r\n    uint256 public _reply_ids;\r\n    mapping(uint256 => dao_uri_struct) public _dao_uris; //_dao_ids              => (Dao)                    Dao Wallet + Dao URI   + Finished\r\n    mapping(uint256 => string) public _template_uris; //_dao_ids              => (Dao)                   Template HTML Code\r\n    mapping(uint256 => join_struct) public _joined_person; //_join_ids             => (Dao)                  join_struct\r\n\r\n    mapping(uint256 => goal_uri_struct) public _goal_uris; //_goal_ids             => (Goal)                   Dao ID + Goal URI\r\n    mapping(uint256 => ideas_uri_struct) public _ideas_uris; //_ideas_ids            => (Ideas)                  Goal ID + Ideas URI\r\n    mapping(string => uint256) public _donated; //string            => (Donated to ideas)                amount\r\n    mapping(uint256 => donation_struct) public _donations; //uint256            => donation_struct\r\n    mapping(uint256 => smart_contract_uri_struct) public _smart_contracts_uris; //_smart_contract_ids   => (Ideas Smart contract)   Goal ID + Ideas URI\r\n    mapping(uint256 => goal_ideas_votes_struct) public all_goal_ideas_votes; //_ideas_vote_ids       => (Vote)                   Goal ID + Ideas ID + Wallet\r\n\r\n    mapping(uint256 => message_struct) public all_messages; // all_messages        => _message_ids + message_struct\r\n\r\n    mapping(uint256 => message_read_struct) public all_read_messages; // all_read_messages        => _message_read_ids + message_read_struct\r\n\r\n    mapping(uint256 => reply_struct) public all_replies; // all_messages        => _reply_ids + reply_struct\r\n    mapping(string => user_badge_struct) public _user_badges; //string            => user_badge_struct\r\n\r\n    //Daos\r\n    function create_dao(string memory _dao_wallet, string memory _dao_uri, string memory _template) public returns (uint256) {\r\n        //Create Dao into _dao_uris\r\n        _dao_uris[_dao_ids] = dao_uri_struct(_dao_wallet, _dao_uri, 'False');\r\n        _template_uris[_dao_ids] = _template;\r\n        _user_badges[_dao_wallet].dao = true;\r\n        _dao_ids++;\r\n\r\n        return _dao_ids;\r\n    }\r\n\r\n    function update_template(uint256 _dao_id, string memory _template) public {\r\n        _template_uris[_dao_id] = _template;\r\n    }\r\n\r\n    function set_dao(uint256 _dao_id, string memory _dao_wallet, string memory _dao_uri) public {\r\n        //Set Dao of wallet and uri\r\n        _dao_uris[_dao_id].dao_wallet = _dao_wallet;\r\n        _dao_uris[_dao_id].dao_uri = _dao_uri;\r\n    }\r\n\r\n    function get_all_daos() public view returns (string[] memory) {\r\n        //Getting all doas\r\n        string[] memory _StoreInfo = new string[](_dao_ids);\r\n        for (uint256 i = 0; i < _dao_ids; i++) {\r\n            _StoreInfo[i] = _dao_uris[i].dao_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function dao_uri(uint256 _dao_id) public view returns (string memory) {\r\n        //Getting one dao URI\r\n        return _dao_uris[_dao_id].dao_uri;\r\n    }\r\n\r\n    //Goals\r\n    function create_goal(string memory _goal_uri, uint256 _dao_id,string memory _wallet) public returns (uint256) {\r\n        //Create goal into _goal_uris\r\n        _goal_uris[_goal_ids] = goal_uri_struct(_dao_id, _goal_uri);\r\n        _user_badges[_wallet].goal = true;\r\n        _goal_ids++;\r\n\r\n        return _goal_ids;\r\n    }\r\n\r\n    function set_goal(uint256 _goal_id, string memory _goal_uri) public {\r\n        //Set goal uri\r\n        _goal_uris[_goal_id].goal_uri = _goal_uri;\r\n    }\r\n\r\n    function get_all_goals() public view returns (string[] memory) {\r\n        //Getting all goals\r\n        string[] memory _StoreInfo = new string[](_goal_ids);\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            _StoreInfo[i] = _goal_uris[i].goal_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_all_goals_by_dao_id(uint256 _dao_id) public view returns (string[] memory) {\r\n        //Getting all goals by dao id\r\n        string[] memory _StoreInfo = new string[](_goal_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            if (_goal_uris[i].dao_id == _dao_id) {\r\n                _StoreInfo[_store_id] = _goal_uris[i].goal_uri;\r\n                _store_id++;\r\n            }\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_goal_id_by_goal_uri(string memory _goal_uri) public view returns (uint256) {\r\n        //Getting goal id by uri\r\n        for (uint256 i = 0; i < _goal_ids; i++) {\r\n            if (keccak256(bytes(_goal_uris[i].goal_uri)) == keccak256(bytes(_goal_uri))) return i;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function goal_uri(uint256 _goal_id) public view returns (string memory) {\r\n        //Getting one goal URI\r\n        return _goal_uris[_goal_id].goal_uri;\r\n    }\r\n\r\n    //Ideas\r\n    function create_ideas(string memory _ideas_uri, uint256 _goal_id, string[] memory _smart_contracts,string memory _wallet) public returns (uint256) {\r\n        //Create ideas into _ideas_uris\r\n        _ideas_uris[_ideas_ids] = ideas_uri_struct(_goal_id, _ideas_uri, 0);\r\n        _user_badges[_wallet].ideas = true;\r\n        _ideas_ids++;\r\n\r\n        for (uint256 i = 0; i < _smart_contracts.length; i++) {\r\n            create_ideas_smart_contract(_ideas_ids, _smart_contract_ids, _smart_contracts[i]);\r\n            _smart_contract_ids++;\r\n        }\r\n\r\n        return _ideas_ids;\r\n    }\r\n\r\n    function create_ideas_smart_contract(uint256 _ideas_id, uint256 _smart_contract_id, string memory _smart_contract) private {\r\n        _smart_contracts_uris[_smart_contract_id] = smart_contract_uri_struct(_ideas_id, _smart_contract_id, _smart_contract);\r\n    }\r\n\r\n    function set_ideas(uint256 _ideas_id, string memory _ideas_uri) public {\r\n        _ideas_uris[_ideas_id].ideas_uri = _ideas_uri;\r\n    }\r\n\r\n    function add_donation(uint256 _ideas_id, uint256 _doantion, string memory _donator) public {\r\n        _user_badges[_donator].donation = true;\r\n        _ideas_uris[_ideas_id].donation += _doantion;\r\n        _donated[_donator] += _doantion;\r\n        _donations[_donations_ids] = donation_struct(_ideas_id, _donator, _doantion);\r\n        _donations_ids++;\r\n    }\r\n\r\n    function join_community(uint256 dao_id, string memory person) public {\r\n        _user_badges[person].joined = true;\r\n        _joined_person[_join_ids] = join_struct({daoid: dao_id, wallet: person});\r\n        _join_ids++;\r\n    }\r\n\r\n    function is_person_joined(string memory wallet) public view returns (bool) {\r\n        //Getting goal id by uri\r\n        for (uint256 i = 0; i < _join_ids; i++) {\r\n            if (keccak256(bytes(_joined_person[i].wallet)) == keccak256(bytes(wallet))) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function get_all_ideas() public view returns (string[] memory) {\r\n        //Getting all ideas\r\n        string[] memory _StoreInfo = new string[](_ideas_ids);\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            _StoreInfo[i] = _ideas_uris[i].ideas_uri;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_all_ideas_by_goal_id(uint256 _goal_id) public view returns (string[] memory) {\r\n        //Getting all ideas by goal id\r\n        string[] memory _StoreInfo = new string[](_ideas_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (_ideas_uris[i].goal_id == _goal_id) _StoreInfo[_store_id] = _ideas_uris[i].ideas_uri;\r\n            _store_id++;\r\n        }\r\n\r\n        return _StoreInfo;\r\n    }\r\n\r\n    function get_ideas_id_by_ideas_uri(string memory _ideas_uri) public view returns (uint256) {\r\n        //Getting ideas id by uri\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (keccak256(bytes(_ideas_uris[i].ideas_uri)) == keccak256(bytes(_ideas_uri))) return i;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function get_goal_id_from_ideas_uri(string memory _ideas_uri) public view returns (uint256) {\r\n        //Getting ideas id by uri\r\n        for (uint256 i = 0; i < _ideas_ids; i++) {\r\n            if (keccak256(bytes(_ideas_uris[i].ideas_uri)) == keccak256(bytes(_ideas_uri))) return _ideas_uris[i].goal_id;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function ideas_uri(uint256 _ideas_id) public view returns (string memory) {\r\n        //Getting one ideas URI\r\n        return _ideas_uris[_ideas_id].ideas_uri;\r\n    }\r\n\r\n    //Votes\r\n    function create_goal_ideas_vote(uint256 _goal_id, uint256 _ideas_id, string memory _wallet) public returns (uint256) {\r\n         _user_badges[_wallet].vote = true;\r\n        //Create votes into all_goal_ideas_votes\r\n        all_goal_ideas_votes[_ideas_vote_ids] = goal_ideas_votes_struct(_goal_id, _ideas_id, _wallet);\r\n        _ideas_vote_ids++;\r\n\r\n        return _ideas_vote_ids;\r\n    }\r\n\r\n    function get_ideas_votes_from_goal(uint256 _goal_id, uint256 _ideas_id) public view returns (string[] memory) {\r\n        //gets all ideas votes from goal\r\n        string[] memory _StoreInfo = new string[](_ideas_vote_ids);\r\n        uint256 _store_id;\r\n        for (uint256 i = 0; i < _ideas_vote_ids; i++) {\r\n            if (all_goal_ideas_votes[i].goal_id == _goal_id && all_goal_ideas_votes[i].ideas_id == _ideas_id) _StoreInfo[_store_id] = all_goal_ideas_votes[i].wallet;\r\n            _store_id++;\r\n        }\r\n        return _StoreInfo;\r\n    }\r\n\r\n    //Messages\r\n    function sendMsg(uint256 _ideas_id, string memory _message, string memory _sender) public returns (uint256) {\r\n            _user_badges[_sender].comment = true;\r\n        //Create messsage into all_messages\r\n        all_messages[_message_ids] = message_struct(_message_ids, _ideas_id, _message, _sender);\r\n        _message_ids++;\r\n\r\n        return _message_ids;\r\n    }\r\n\r\n    function getMsgIDs(uint256 ideas_id) public view returns (uint256[] memory) {\r\n        //Getting all messages ids by idea id\r\n        uint256[] memory _All_Ideas_Messages = new uint256[](_message_ids);\r\n        uint256 _msg_id;\r\n        for (uint256 i = 0; i < _message_ids; i++) {\r\n            if (all_messages[i].ideas_id == ideas_id) {\r\n                _All_Ideas_Messages[_msg_id] = all_messages[i].message_id;\r\n                _msg_id++;\r\n            }\r\n        }\r\n\r\n        return _All_Ideas_Messages;\r\n    }\r\n\r\n    function sendReply(uint256 _message_id, string memory _reply,uint256 ideas_id,string memory _wallet) public returns (uint256) {\r\n          _user_badges[_wallet].reply = true;\r\n        //Create reply into all_replies\r\n        all_replies[_reply_ids] = reply_struct(_reply_ids, _message_id,ideas_id, _reply);\r\n        _reply_ids++;\r\n\r\n        return _reply_ids;\r\n    }\r\n\r\n    function getReplyIDs(uint256 message_id) public view returns (uint256[] memory) {\r\n        //Getting all messages ids by idea id\r\n        uint256[] memory _All_Messages_Replys = new uint256[](_reply_ids);\r\n        uint256 _reply_id;\r\n        for (uint256 i = 0; i < _reply_ids; i++) {\r\n            if (all_replies[i].message_id == message_id) {\r\n                _All_Messages_Replys[_reply_id] = all_replies[i].reply_id;\r\n                _reply_id++;\r\n            }\r\n        }\r\n\r\n        return _All_Messages_Replys;\r\n    }\r\n\r\n    function sendReadMsg(uint256 _message_id, uint256 _ideas_id,string memory _wallet, string memory msg_type) public returns (uint256) {\r\n        //Create messsage into all_messages\r\n        all_read_messages[_message_read_ids] = message_read_struct(_message_id, _ideas_id, _wallet,msg_type);\r\n        _message_read_ids++;\r\n\r\n        return _message_read_ids;\r\n    }\r\n\r\n\r\n\r\n  function getReadMsg(uint256 _message_id, string memory msg_type)  public view returns (bool) {\r\n       \r\n       bool read = false;\r\n        for (uint256 i = 0; i < _message_read_ids; i++) {\r\n            if (all_read_messages[i].message_id == _message_id && keccak256(bytes(msg_type)) == keccak256(bytes(all_read_messages[i].msg_type))) {\r\n               read = true; \r\n            }\r\n        }\r\n\r\n        return read;\r\n    }\r\n\r\n\r\n\r\n    function reset_all() public {\r\n        for (uint256 i = 0; i < _dao_ids; i++) delete _dao_uris[i];\r\n        for (uint256 i = 0; i < _goal_ids; i++) delete _goal_uris[i];\r\n        for (uint256 i = 0; i < _ideas_ids; i++) delete _ideas_uris[i];\r\n        for (uint256 i = 0; i < _goal_ids; i++) delete _smart_contracts_uris[i];\r\n        for (uint256 i = 0; i < _message_ids; i++) delete all_messages[i];\r\n        for (uint256 i = 0; i < _reply_ids; i++) delete all_replies[i];\r\n        for (uint256 i = 0; i < _ideas_vote_ids; i++) delete all_goal_ideas_votes[i];\r\n        _dao_ids = 0;\r\n        _goal_ids = 0;\r\n        _ideas_ids = 0;\r\n        _message_ids = 0;\r\n        _reply_ids = 0;\r\n        _ideas_vote_ids = 0;\r\n    }\r\n\r\n   \r\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}